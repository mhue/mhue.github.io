<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Tournoi Progressif des Profils üçèüçé</title>
  <style>
    body { font-family: sans-serif; background: #f4f4f4; padding: 2em; max-width: 1000px; margin: auto; }
    h1 { text-align: center; }
    .controls {
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: white;
      border-radius: 10px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .time-input {
      margin: 10px;
      padding: 10px;
      font-size: 16px;
      border: 2px solid #ddd;
      border-radius: 5px;
      width: 100px;
    }
    .btn {
      margin: 5px;
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background 0.3s;
    }
    .btn-primary { background: #4CAF50; color: white; }
    .btn-primary:hover { background: #45a049; }
    .btn-secondary { background: #2196F3; color: white; }
    .btn-secondary:hover { background: #1976D2; }
    .btn-danger { background: #f44336; color: white; }
    .btn-danger:hover { background: #d32f2f; }
    .status {
      margin: 10px 0;
      font-weight: bold;
      font-size: 18px;
    }
    .status.running { color: #4CAF50; }
    .status.paused { color: #FF9800; }
    .status.stopped { color: #f44336; }
    .joueur { display: flex; align-items: center; margin: 10px 0; }
    .emoji { font-size: 1.5em; width: 40px; text-align: center; }
    .nom { flex: 1; }
    .barre {
      height: 24px;
      background: #aed581;
      border-radius: 12px;
      transition: width 0.5s;
    }
    .progress-container { flex: 3; background: #e0e0e0; border-radius: 12px; overflow: hidden; margin: 0 10px; }
    .score { width: 60px; text-align: right; font-weight: bold; }
  </style>
</head>
<body>
<h1>üçé Tournoi Round-Robin des Profils üçè</h1>

<div class="controls">
  <div>
    <label for="tournamentTime">Dur√©e du tournoi :</label>
    <input type="number" id="tournamentTime" class="time-input" value="30" min="5" max="300">
    <span>secondes</span>
  </div>
  <div class="status" id="status">Pr√™t √† d√©marrer</div>
  <div>
    <button class="btn btn-primary" id="startBtn" onclick="startTournament()">‚ñ∂Ô∏è D√©marrer</button>
    <button class="btn btn-secondary" id="pauseBtn" onclick="pauseTournament()" disabled>‚è∏Ô∏è Pause</button>
    <button class="btn btn-danger" id="resetBtn" onclick="resetTournament()">üîÑ Reset</button>
  </div>
</div>

<div id="tableau"></div>

<script>
const profils = [
  ['üåü', 'GENTILLE'], ['üò†', 'M√âCHANTE'], ['üåô', 'LUNATIQUE'], ['ü§ù', 'DONNANT-DONNANT'],
  ['ü§®', 'RANCUNI√àRE'], ['‚è∞', 'P√âRIODIQUE-M√âCHANTE'], ['‚è≥', 'P√âRIODIQUE-GENTILLE'], ['ü§ó', 'MAJORIT√â-MOU'],
  ['üïµÔ∏è', 'M√âFIANTE'], ['üí™', 'MAJORIT√â-DUR'], ['üß™', 'SONDEUR'], ['üßä', 'DONNANT-DONNANT-DUR']
];

let scores = Object.fromEntries(profils.map(([_, nom]) => [nom, 0]));
const gain = { 'CC': [3, 3], 'CD': [0, 5], 'DC': [5, 0], 'DD': [1, 1] };
const nbTours = 10;
const tableau = document.getElementById("tableau");

// Tournament control variables
let tournamentRunning = false;
let tournamentPaused = false;
let matchDelay = 100;
let totalMatches = 0;
let currentMatch = 0;
let startTime = 0;

function updateUI() {
  tableau.innerHTML = "";
  const classement = Object.entries(scores).sort((a, b) => b[1] - a[1]);
  classement.forEach(([nom, score]) => {
    const [emoji] = profils.find(p => p[1] === nom);
    const pourcent = score / (nbTours * 5 * (profils.length - 1)) * 100;
    tableau.innerHTML += `
      <div class="joueur">
        <div class="emoji">${emoji}</div>
        <div class="nom">${nom}</div>
        <div class="progress-container">
          <div class="barre" style="width: ${pourcent}%;"></div>
        </div>
        <div class="score">${score} üçé</div>
      </div>
    `;
  });
}

function strategie(profil, historique, moi, adv) {
  const tour = historique.length;
  const maj = (arr) => arr.reduce((a, b) => a + (b === 'C' ? 1 : 0), 0) >= arr.length / 2 ? 'C' : 'D';
  switch (profil) {
    case "GENTILLE": return 'C';
    case "M√âCHANTE": return 'D';
    case "LUNATIQUE": return Math.random() < 0.5 ? 'C' : 'D';
    case "DONNANT-DONNANT": return tour === 0 ? 'C' : historique[tour - 1][adv];
    case "RANCUNI√àRE": return historique.some(h => h[adv] === 'D') ? 'D' : 'C';
    case "P√âRIODIQUE-M√âCHANTE": return ['D', 'D', 'C'][tour % 3];
    case "P√âRIODIQUE-GENTILLE": return ['C', 'C', 'D'][tour % 3];
    case "MAJORIT√â-MOU":
      return tour === 0 ? 'C' : maj(historique.map(h => h[adv]));
    case "M√âFIANTE": return tour === 0 ? 'D' : historique[tour - 1][adv];
    case "MAJORIT√â-DUR":
      return tour === 0 ? 'D' : maj(historique.map(h => h[adv])) === 'C' ? 'C' : 'D';
    case "SONDEUR":
      if (tour === 0) return 'D';
      if (tour === 1 || tour === 2) return 'C';
      const coop2et3 = historique[1]?.[adv] === 'C' && historique[2]?.[adv] === 'C';
      if (coop2et3) return 'D';
      return historique[tour - 1][adv];
    case "DONNANT-DONNANT-DUR":
      if (tour < 2) return 'C';
      return (historique[tour - 1][adv] === 'D' || historique[tour - 2][adv] === 'D') ? 'D' : 'C';
  }
}

async function simulateMatch(nom1, nom2) {
  let historique = [];
  let score1 = 0, score2 = 0;
  for (let t = 0; t < nbTours; t++) {
    const c1 = strategie(nom1, historique, 'p1', 'p2');
    const c2 = strategie(nom2, historique, 'p2', 'p1');
    const [s1, s2] = gain[c1 + c2];
    historique.push({ p1: c1, p2: c2 });
    score1 += s1;
    score2 += s2;
  }
  scores[nom1] += score1;
  scores[nom2] += score2;
  currentMatch++;
  updateUI();
  updateStatus();
  
  // Wait for pause to be lifted if tournament is paused
  while (tournamentPaused && tournamentRunning) {
    await new Promise(r => setTimeout(r, 100));
  }
  
  // Only delay if tournament is still running
  if (tournamentRunning) {
    await new Promise(r => setTimeout(r, matchDelay));
  }
}

async function tournoiRoundRobin() {
  for (let round = 0; round < profils.length - 1 && tournamentRunning; round++) {
    const rotating = [...profils.slice(0, profils.length - 1)].slice(round).concat(profils.slice(0, round));
    const pairings = [];
    for (let i = 0; i < (rotating.length - 1) / 2; i++) {
      pairings.push([rotating[i + 1][1], rotating[rotating.length - 1 - i][1]]);
    }
    pairings.push([profils[profils.length - 1][1], rotating[0][1]]);
    for (let [a, b] of pairings) {
      if (!tournamentRunning) break;
      await simulateMatch(a, b);
    }
  }
  
  if (tournamentRunning) {
    tournamentRunning = false;
    updateStatus("Tournoi termin√© ! üèÅ");
    document.getElementById('startBtn').disabled = false;
    document.getElementById('pauseBtn').disabled = true;
  }
}

// Calculate total number of matches in a round-robin tournament
function calculateTotalMatches() {
  const n = profils.length;
  return (n * (n - 1)) / 2;
}

// Update status display
function updateStatus(customMessage = null) {
  const statusElement = document.getElementById('status');
  
  if (customMessage) {
    statusElement.textContent = customMessage;
    statusElement.className = 'status';
    return;
  }
  
  if (!tournamentRunning) {
    statusElement.textContent = 'Pr√™t √† d√©marrer';
    statusElement.className = 'status';
  } else if (tournamentPaused) {
    statusElement.textContent = `En pause (${currentMatch}/${totalMatches} matchs)`;
    statusElement.className = 'status paused';
  } else {
    const elapsed = Math.floor((Date.now() - startTime) / 1000);
    const tournamentDuration = parseInt(document.getElementById('tournamentTime').value);
    const remaining = Math.max(0, tournamentDuration - elapsed);
    statusElement.textContent = `En cours... ${currentMatch}/${totalMatches} matchs - ${remaining}s restantes`;
    statusElement.className = 'status running';
  }
}

// Start tournament
function startTournament() {
  const tournamentTimeInput = document.getElementById('tournamentTime');
  const tournamentDuration = parseInt(tournamentTimeInput.value);
  
  if (tournamentDuration < 5 || tournamentDuration > 300) {
    alert('La dur√©e doit √™tre entre 5 et 300 secondes');
    return;
  }
  
  // Calculate delay between matches
  totalMatches = calculateTotalMatches();
  matchDelay = Math.max(50, (tournamentDuration * 1000) / totalMatches);
  
  // Reset tournament state
  currentMatch = 0;
  startTime = Date.now();
  tournamentRunning = true;
  tournamentPaused = false;
  
  // Update UI
  document.getElementById('startBtn').disabled = true;
  document.getElementById('pauseBtn').disabled = false;
  tournamentTimeInput.disabled = true;
  
  // Start tournament
  tournoiRoundRobin();
}

// Pause/Resume tournament
function pauseTournament() {
  const pauseBtn = document.getElementById('pauseBtn');
  
  if (tournamentPaused) {
    tournamentPaused = false;
    pauseBtn.textContent = '‚è∏Ô∏è Pause';
    startTime = Date.now() - (currentMatch * matchDelay);
  } else {
    tournamentPaused = true;
    pauseBtn.textContent = '‚ñ∂Ô∏è Reprendre';
  }
  
  updateStatus();
}

// Reset tournament
function resetTournament() {
  tournamentRunning = false;
  tournamentPaused = false;
  currentMatch = 0;
  
  // Reset scores
  scores = Object.fromEntries(profils.map(([_, nom]) => [nom, 0]));
  
  // Reset UI
  document.getElementById('startBtn').disabled = false;
  document.getElementById('pauseBtn').disabled = true;
  document.getElementById('pauseBtn').textContent = '‚è∏Ô∏è Pause';
  document.getElementById('tournamentTime').disabled = false;
  
  updateUI();
  updateStatus();
}

// Initialize UI
updateUI();
updateStatus();
</script>
</body>
</html>

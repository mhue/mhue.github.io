<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jeu du pommier it√©r√©</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.3.2/pixi.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      padding: 1em;
      margin: auto;
      background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
      min-height: 100vh;
    }
    .container {
      max-width: 1200px;
      margin: auto;
      position: relative;
    }
    h1 {
      text-align: center;
      color: #2F4F4F;
      margin-bottom: 1em;
    }
    .game-controls {
      text-align: center;
      margin-bottom: 1em;
    }

    button {
      font-size: 1.2em;
      margin: 0.5em;
      padding: 0.8em 1.5em;
      border: none;
      border-radius: 8px;
      background: #4CAF50;
      color: white;
      cursor: pointer;
      transition: background 0.3s;
    }
    button:hover {
      background: #45a049;
    }
    .share-btn {
      background: #2196F3;
    }
    .share-btn:hover {
      background: #1976D2;
    }
    .game-area {
      display: flex;
      gap: 2em;
      margin-bottom: 2em;
    }
    .game-canvas {
      flex: 1;
      border: 3px solid #8B4513;
      border-radius: 10px;
      background: #87CEEB;
    }
    .game-info {
      flex: 0 0 300px;
      background: rgba(255, 255, 255, 0.9);
      padding: 1em;
      border-radius: 10px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    .score {
      font-size: 1.5em;
      font-weight: bold;
      margin-bottom: 1em;
      text-align: center;
      padding: 1em;
      background: linear-gradient(135deg, #FFD700, #FFA500);
      border-radius: 10px;
      border: 3px solid #FF8C00;
      color: #8B4513;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
      box-shadow: 0 4px 12px rgba(255,140,0,0.3);
    }
    .score table {
      width: 100%;
      border-collapse: collapse;
    }
    .score td {
      padding: 0.3em 0.5em;
      border: none;
    }
    .score td:first-child {
      text-align: left;
      font-weight: normal;
    }
    .score td:last-child {
      text-align: right;
      font-weight: bold;
      font-size: 1.2em;
    }
    .historique {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.9em;
    }
    .historique th, .historique td {
      border: 1px solid #aaa;
      padding: 0.3em;
      text-align: center;
    }
    .historique th {
      background: #f0f0f0;
    }

    /* Mobile responsive styles */
    @media (max-width: 768px) {
      body {
        padding: 0.5em;
      }
      
      .container {
        max-width: 100%;
      }
      
      h1 {
        font-size: 1.5em;
        margin-bottom: 0.5em;
      }
      
      .game-controls p {
        font-size: 0.9em;
        margin-bottom: 0.5em;
      }
      
      button {
        font-size: 1em;
        margin: 0.3em;
        padding: 0.6em 1.2em;
      }
      
      .game-area {
        flex-direction: column;
        gap: 1em;
      }
      
      .game-canvas {
        order: 1;
        width: 100%;
        height: auto;
      }
      
      .game-info {
        order: 2;
        flex: none;
        width: 100%;
        margin: 0;
      }
      
      .score {
        font-size: 1.2em;
        padding: 0.8em;
        margin-bottom: 0.8em;
      }
      
      .score td:last-child {
        font-size: 1.1em;
      }
      
      .historique {
        font-size: 0.8em;
      }
      
      .historique th, .historique td {
        padding: 0.2em;
      }
    }

    @media (max-width: 480px) {
      body {
        padding: 0.3em;
      }
      
      h1 {
        font-size: 1.3em;
      }
      
      button {
        font-size: 0.9em;
        padding: 0.5em 1em;
        margin: 0.2em;
      }
      
      .score {
        font-size: 1.1em;
        padding: 0.6em;
      }
      
      .historique {
        font-size: 0.7em;
      }
    }

  </style>
</head>
<body>

<div class="container">
  <h1>üçé Jeu du Pommier It√©r√© üçé</h1>
  
  <div class="game-controls">
    <p>Choisissez votre action :</p>
    <button class="share-btn" onclick="jouerUnTour('P')">ü§ù Partager</button>
    <button onclick="jouerUnTour('G')">‚öîÔ∏è Garder</button>
  </div>
  


  <div class="game-area">
    <div id="gameCanvas" class="game-canvas"></div>
    
    <div class="game-info">
      <div class="score">
        <table id="tableauScores">
          <tr>
            <td>Votre score</td>
            <td id="scoreJoueur">0</td>
          </tr>
                      <tr>
              <td>Score du robot</td>
              <td id="scoreRobot">0</td>
            </tr>
        </table>
      </div>
      
      <table class="historique" id="tableHistorique">
        <thead>
          <tr>
            <th>Tour</th>
            <th>Vous</th>
            <th>Robot</th>
            <th>Points</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>
</div>

<script>
  // Game logic variables
  const gain = {
    'PP': [3, 3],
    'PG': [0, 5],
    'GP': [5, 0],
    'GG': [1, 1]
  };

  let historique = [];
  let scoreJoueur = 0;
  let scoreRobot = 0;

  // Physics and graphics variables
  let app;
  let engine;
  let world;
  let bucketLeft, bucketRight;
  let apples = [];
  let bucketBodies = [];

  // Game settings - will be adjusted for screen size
  let CANVAS_WIDTH = 800;
  let CANVAS_HEIGHT = 600;
  let BUCKET_WIDTH = 180;
  let BUCKET_HEIGHT = 120;
  let BUCKET_WALL_THICKNESS = 12;
  let APPLE_RADIUS = 12;

  // Adjust canvas and game elements size based on screen
  function adjustCanvasSize() {
    const screenWidth = window.innerWidth;
    const screenHeight = window.innerHeight;
    
    if (screenWidth <= 480) {
      // Very small mobile screens
      CANVAS_WIDTH = Math.min(screenWidth - 20, 400);
      CANVAS_HEIGHT = Math.min(screenHeight * 0.5, 300);
      BUCKET_WIDTH = 120;
      BUCKET_HEIGHT = 80;
      BUCKET_WALL_THICKNESS = 8;
      APPLE_RADIUS = 8;
    } else if (screenWidth <= 768) {
      // Mobile screens
      CANVAS_WIDTH = Math.min(screenWidth - 40, 600);
      CANVAS_HEIGHT = Math.min(screenHeight * 0.6, 450);
      BUCKET_WIDTH = 140;
      BUCKET_HEIGHT = 100;
      BUCKET_WALL_THICKNESS = 10;
      APPLE_RADIUS = 10;
    } else {
      // Desktop screens - use original values
      CANVAS_WIDTH = 800;
      CANVAS_HEIGHT = 600;
      BUCKET_WIDTH = 180;
      BUCKET_HEIGHT = 120;
      BUCKET_WALL_THICKNESS = 12;
      APPLE_RADIUS = 12;
    }
  }

  // Initialize the game
  function initGame() {
    // Adjust canvas size for mobile
    adjustCanvasSize();
    
    // Create PIXI application
    app = new PIXI.Application({
      width: CANVAS_WIDTH,
      height: CANVAS_HEIGHT,
      backgroundColor: 0x87CEEB,
      antialias: true
    });
    
    // Make canvas responsive
    app.view.style.width = '100%';
    app.view.style.height = 'auto';
    app.view.style.maxWidth = '800px';
    app.view.style.display = 'block';
    
    document.getElementById('gameCanvas').appendChild(app.view);

    // Create Matter.js engine
    engine = Matter.Engine.create();
    world = engine.world;
    engine.world.gravity.y = 0.8;

    // Create buckets
    createBuckets();

    // Start the physics loop
    Matter.Engine.run(engine);
    
    // Start the render loop
    app.ticker.add(updatePhysics);
  }

  function createBuckets() {
    const bucketY = CANVAS_HEIGHT - BUCKET_HEIGHT - 20;
    
    // Calculate responsive bucket positions
    const margin = Math.max(20, CANVAS_WIDTH * 0.05); // 5% margin or minimum 20px
    const availableWidth = CANVAS_WIDTH - (2 * margin) - (2 * BUCKET_WIDTH);
    const spacing = Math.max(20, availableWidth * 0.3); // Space between buckets
    
    const leftBucketX = margin;
    const rightBucketX = CANVAS_WIDTH - margin - BUCKET_WIDTH;

    // Create left bucket
    bucketLeft = createBucket(leftBucketX, bucketY, 0xFF6B6B); // Red-ish for player
    
    // Create right bucket  
    bucketRight = createBucket(rightBucketX, bucketY, 0x4ECDC4); // Teal for bot
  }

  function createBucket(x, y, color) {
    const bucket = new PIXI.Container();
    
    // Visual bucket
    const bucketGraphics = new PIXI.Graphics();
    bucketGraphics.beginFill(color, 0.8);
    bucketGraphics.drawRect(0, 0, BUCKET_WIDTH, BUCKET_HEIGHT);
    bucketGraphics.beginFill(color, 1);
    // Left wall
    bucketGraphics.drawRect(0, 0, BUCKET_WALL_THICKNESS, BUCKET_HEIGHT);
    // Right wall
    bucketGraphics.drawRect(BUCKET_WIDTH - BUCKET_WALL_THICKNESS, 0, BUCKET_WALL_THICKNESS, BUCKET_HEIGHT);
    // Bottom
    bucketGraphics.drawRect(0, BUCKET_HEIGHT - BUCKET_WALL_THICKNESS, BUCKET_WIDTH, BUCKET_WALL_THICKNESS);
    
    bucket.addChild(bucketGraphics);
    bucket.x = x;
    bucket.y = y;
    app.stage.addChild(bucket);

    // Physics bodies for bucket walls
    const leftWall = Matter.Bodies.rectangle(
      x + BUCKET_WALL_THICKNESS/2, 
      y + BUCKET_HEIGHT/2, 
      BUCKET_WALL_THICKNESS, 
      BUCKET_HEIGHT, 
      { isStatic: true }
    );
    
    const rightWall = Matter.Bodies.rectangle(
      x + BUCKET_WIDTH - BUCKET_WALL_THICKNESS/2, 
      y + BUCKET_HEIGHT/2, 
      BUCKET_WALL_THICKNESS, 
      BUCKET_HEIGHT, 
      { isStatic: true }
    );
    
    const bottom = Matter.Bodies.rectangle(
      x + BUCKET_WIDTH/2, 
      y + BUCKET_HEIGHT - BUCKET_WALL_THICKNESS/2, 
      BUCKET_WIDTH, 
      BUCKET_WALL_THICKNESS, 
      { isStatic: true }
    );

    Matter.World.add(world, [leftWall, rightWall, bottom]);
    bucketBodies.push(leftWall, rightWall, bottom);

    return bucket;
  }

  function createApple(x, y, isPlayer) {
    // Create physics body
    const body = Matter.Bodies.circle(x, y, APPLE_RADIUS, {
      restitution: 0.3,
      friction: 0.8,
      density: 0.001
    });

    // Create visual apple
    const appleGraphics = new PIXI.Graphics();
    appleGraphics.beginFill(isPlayer ? 0xFF4444 : 0x44FF44); // Red for player, green for bot
    appleGraphics.drawCircle(0, 0, APPLE_RADIUS);
    appleGraphics.beginFill(0x8B4513); // Brown stem
    appleGraphics.drawRect(-1, -APPLE_RADIUS-3, 2, 4);
    
    app.stage.addChild(appleGraphics);
    
    Matter.World.add(world, body);
    
    const apple = {
      body: body,
      graphics: appleGraphics,
      isPlayer: isPlayer
    };
    
    apples.push(apple);
    return apple;
  }

  function dropApples(playerPoints, botPoints) {
    // Drop apples for player
    for (let i = 0; i < playerPoints; i++) {
      setTimeout(() => {
        // Use responsive spread based on bucket width
        const spread = Math.min(60, BUCKET_WIDTH * 0.4);
        const x = bucketLeft.x + BUCKET_WIDTH/2 + (Math.random() - 0.5) * spread;
        const y = -20 - Math.random() * 50;
        createApple(x, y, true);
      }, i * 100 + Math.random() * 100);
    }

    // Drop apples for bot
    for (let i = 0; i < botPoints; i++) {
      setTimeout(() => {
        // Use responsive spread based on bucket width
        const spread = Math.min(60, BUCKET_WIDTH * 0.4);
        const x = bucketRight.x + BUCKET_WIDTH/2 + (Math.random() - 0.5) * spread;
        const y = -20 - Math.random() * 50;
        createApple(x, y, false);
      }, i * 100 + Math.random() * 100);
    }
  }

  function updatePhysics() {
    // Update apple positions
    apples.forEach((apple, index) => {
      apple.graphics.x = apple.body.position.x;
      apple.graphics.y = apple.body.position.y;
      apple.graphics.rotation = apple.body.angle;

      // Remove apples that have fallen too far
      if (apple.body.position.y > CANVAS_HEIGHT + 100) {
        app.stage.removeChild(apple.graphics);
        Matter.World.remove(world, apple.body);
        apples.splice(index, 1);
      }
    });
  }

  function strategieRobot() {
    if (historique.length === 0) return 'P'; // Tit for Tat commence par coop√©rer
    return historique[historique.length - 1].joueur; // Imite le dernier coup du joueur
  }

  function jouerUnTour(coupJoueur) {
    const coupRobot = strategieRobot();
    const cl√© = coupJoueur + coupRobot;
    const [ptsJoueur, ptsRobot] = gain[cl√©];

    scoreJoueur += ptsJoueur;
    scoreRobot += ptsRobot;

    historique.push({ 
      tour: historique.length + 1, 
      joueur: coupJoueur, 
      bot: coupRobot, 
      ptsJoueur, 
      ptsRobot 
    });

    // Drop apples based on points earned
    dropApples(ptsJoueur, ptsRobot);

    mettreAJourInterface();
  }

  function mettreAJourInterface() {
    const tableau = document.getElementById("tableHistorique").querySelector("tbody");
    tableau.innerHTML = "";

    historique.forEach(entree => {
      const ligne = `<tr>
        <td>${entree.tour}</td>
        <td>${entree.joueur === 'P' ? 'ü§ù' : '‚öîÔ∏è'}</td>
        <td>${entree.bot === 'P' ? 'ü§ù' : '‚öîÔ∏è'}</td>
        <td>${entree.ptsJoueur}, ${entree.ptsRobot}</td>
      </tr>`;
      tableau.innerHTML += ligne;
    });

    document.getElementById("scoreJoueur").textContent = scoreJoueur;
    document.getElementById("scoreRobot").textContent = scoreRobot;
  }

  // Initialize the game when page loads
  window.addEventListener('load', initGame);
  
  // Function to recreate buckets with new positions
  function recreateBuckets() {
    // Remove old bucket graphics
    if (bucketLeft) {
      app.stage.removeChild(bucketLeft);
    }
    if (bucketRight) {
      app.stage.removeChild(bucketRight);
    }
    
    // Remove old bucket physics bodies
    bucketBodies.forEach(body => {
      Matter.World.remove(world, body);
    });
    bucketBodies = [];
    
    // Create new buckets with responsive positions
    createBuckets();
  }

  // Handle window resize for responsive canvas
  window.addEventListener('resize', () => {
    if (app) {
      // Debounce resize events
      clearTimeout(window.resizeTimeout);
      window.resizeTimeout = setTimeout(() => {
        const oldWidth = CANVAS_WIDTH;
        const oldHeight = CANVAS_HEIGHT;
        adjustCanvasSize();
        
        // Only recreate if size actually changed significantly
        if (Math.abs(oldWidth - CANVAS_WIDTH) > 50 || Math.abs(oldHeight - CANVAS_HEIGHT) > 50) {
          app.renderer.resize(CANVAS_WIDTH, CANVAS_HEIGHT);
          recreateBuckets();
        }
      }, 250);
    }
  });
</script>

</body>
</html>
